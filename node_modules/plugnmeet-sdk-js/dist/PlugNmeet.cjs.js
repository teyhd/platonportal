var $jMCoD$buffer = require("buffer");
var $jMCoD$http = require("http");
var $jMCoD$https = require("https");
var $jMCoD$crypto = require("crypto");


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "PlugNmeet", () => $405dcbf07186a1ff$export$1402da7f2870faee);




var $e71a992b229cccd4$require$Buffer = $jMCoD$buffer.Buffer;
class $e71a992b229cccd4$export$5a82ec1641dd9681 {
    constructor(apiEndPointURL, apiKey, apiSecret){
        this.isSecure = false;
        this.mainOptions = {};
        this.prepareHeader = (body)=>{
            const signature = (0, $jMCoD$crypto.createHmac)("sha256", this.apiSecret).update(body).digest("hex");
            return {
                "Content-Type": "application/json",
                "API-KEY": this.apiKey,
                "HASH-SIGNATURE": signature
            };
        };
        this.sendRequest = async (path, body)=>{
            return new Promise((resolve)=>{
                const output = {
                    status: false,
                    response: undefined
                };
                const chunk = JSON.stringify(body);
                const options = {
                    ...this.mainOptions
                };
                options.path += path;
                options.headers = this.prepareHeader(chunk);
                const req = (this.isSecure ? (0, ($parcel$interopDefault($jMCoD$https))) : (0, ($parcel$interopDefault($jMCoD$http)))).request(options, (res)=>{
                    const body = [];
                    res.on("data", (chunk)=>body.push(chunk));
                    res.on("end", ()=>{
                        const resString = $e71a992b229cccd4$require$Buffer.concat(body).toString();
                        try {
                            output.status = true;
                            output.response = JSON.parse(resString);
                        } catch (error) {
                            output.status = false;
                            output.response = error;
                        }
                        resolve(output);
                    });
                });
                req.on("error", (error)=>{
                    output.response = error.message;
                    resolve(output);
                });
                req.write(chunk);
                req.end();
            });
        };
        this.apiEndPointURL = apiEndPointURL;
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        const url = new URL(apiEndPointURL);
        let port = url.protocol === "https:" ? 443 : 80;
        this.isSecure = url.protocol === "https:" ? true : false;
        // use port if supplied with url
        if (url.port) port = Number(url.port);
        this.mainOptions = {
            hostname: url.hostname,
            path: url.pathname,
            method: "POST",
            port: port
        };
    }
}


class $405dcbf07186a1ff$export$1402da7f2870faee {
    /**
   * @param serverUrl plugNmeet server URL
   * @param apiKey plugNmeet API_Key
   * @param apiSecret plugNmeet API_Secret
   */ constructor(serverUrl, apiKey, apiSecret){
        this.defaultPath = "/auth";
        this.apiTransport = new (0, $e71a992b229cccd4$export$5a82ec1641dd9681)(serverUrl + this.defaultPath, apiKey, apiSecret);
    }
    /**
   * Create new room
   * @param params
   * @returns Promise<CreateRoomResponse>
   */ async createRoom(params) {
        const output = await this.apiTransport.sendRequest("/room/create", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            room_info: output.response.room_info
        };
    }
    /**
   * Generate join token
   * @param params
   * @returns Promise<JoinTokenResponse>
   */ async getJoinToken(params) {
        const output = await this.apiTransport.sendRequest("/room/getJoinToken", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            token: output.response.token
        };
    }
    /**
   * If room is active or not
   * @param params
   * @returns Promise<IsRoomActiveResponse>
   */ async isRoomActive(params) {
        const output = await this.apiTransport.sendRequest("/room/isRoomActive", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            is_active: output.response.is_active,
            msg: output.response.msg
        };
    }
    /**
   * Get active room information
   * @param params
   * @returns Promise<ActiveRoomInfoResponse>
   */ async getActiveRoomInfo(params) {
        const output = await this.apiTransport.sendRequest("/room/getActiveRoomInfo", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            room: output.response.room
        };
    }
    /**
   * Get all active rooms
   * @returns Promise<ActiveRoomsInfoResponse>
   */ async getActiveRoomsInfo() {
        const output = await this.apiTransport.sendRequest("/room/getActiveRoomsInfo", {});
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            rooms: output.response.rooms
        };
    }
    /**
   * Fetch info about past rooms
   * @param params
   * @returns Promise<FetchRoomsInfoResponse>
   */ async fetchPastRoomsInfo(params) {
        const output = await this.apiTransport.sendRequest("/room/fetchPastRooms", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            result: output.response.result
        };
    }
    /**
   * End active room
   * @param params
   * @returns Promise<EndRoomResponse>
   */ async endRoom(params) {
        const output = await this.apiTransport.sendRequest("/room/endRoom", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg
        };
    }
    /**
   * Fetch analytics
   * @param params
   * @returns Promise<FetchAnalyticsResponse>
   */ async fetchAnalytics(params) {
        const output = await this.apiTransport.sendRequest("/analytics/fetch", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            result: output.response.result
        };
    }
    /**
   * Delete analytics
   * @param params
   * @returns Promise<DeleteAnalyticsResponse>
   */ async deleteAnalytics(params) {
        const output = await this.apiTransport.sendRequest("/analytics/delete", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg
        };
    }
    /**
   * Generate token to download recording
   * @param params
   * @returns Promise<AnalyticsDownloadTokenResponse>
   */ async getAnalyticsDownloadToken(params) {
        const output = await this.apiTransport.sendRequest("/analytics/getDownloadToken", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            token: output.response.token
        };
    }
    /**
   * Fetch recordings
   * @param params
   * @returns Promise<FetchRecordingsResponse>
   */ async fetchRecordings(params) {
        const output = await this.apiTransport.sendRequest("/recording/fetch", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            result: output.response.result
        };
    }
    /**
   * Delete recording
   * @param params
   * @returns Promise<DeleteRecordingsResponse>
   */ async deleteRecordings(params) {
        const output = await this.apiTransport.sendRequest("/recording/delete", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg
        };
    }
    /**
   * Generate token to download recording
   * @param params
   * @returns Promise<RecordingDownloadTokenResponse>
   */ async getRecordingDownloadToken(params) {
        const output = await this.apiTransport.sendRequest("/recording/getDownloadToken", params);
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            token: output.response.token
        };
    }
    /**
   * To get JS & CSS files to build interface
   * @returns Promise<ClientFilesResponse>
   */ async getClientFiles() {
        const output = await this.apiTransport.sendRequest("/getClientFiles", {});
        if (!output.status) return {
            status: false,
            msg: output.response
        };
        return {
            status: output.response.status,
            msg: output.response.msg,
            css: output.response.css,
            js: output.response.js
        };
    }
}


//# sourceMappingURL=PlugNmeet.cjs.js.map
